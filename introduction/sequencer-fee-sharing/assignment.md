# Assignment

{% hint style="danger" %}
To assign your contact to an SFS NFT you need to do some code changes so please check [assign-a-smart-contract](../../build-on-mode/sfs-sequencer-fee-sharing/assign-a-smart-contract/ "mention") before deploying your final version.
{% endhint %}

Assigning a contract to the SFS means linking your smart contract to an already existing SFS NFT. This also means that the revenue generated by that smart contract can be claimed with this NFT.

When you assign a contract there is no NFT being minted. This is useful when dApps have more than one smart contract then you can just register one contract to create the SFS NFT and assign the rest of the contracts to one SFS NFT. By doing this, you will have all the revenue from those contracts accumulated on one NFT.

Several contracts can be assigned to the same SFS NFT

Every contract can only be assigned to one SFS NFT

This is the code of the assign function:

{% code fullWidth="true" %}
```solidity
    /// @notice Assigns smart contract to existing NFT. That NFT will collect fees generated by the smart contract.
    ///         Callable only by smart contract itself.
    /// @param _tokenId tokenId which will collect fees
    /// @return tokenId of the ownership NFT that collects fees
    function assign(uint256 _tokenId) public onlyUnregistered returns (uint256) {
       address smartContract = msg.sender;


       if (!_exists(_tokenId)) revert InvalidTokenId();


       emit Assign(smartContract, _tokenId);


       feeRecipient[smartContract] = NftData({
           tokenId: _tokenId,
           registered: true,
           balanceUpdatedBlock: block.number
       });


       return _tokenId;
   }
```
{% endcode %}

Here are a few things to note:

1. The assign function needs to be called by a smart contract and not an EOA. Itâ€™s the same as the register function at this point.
2. The assign function does not mint an ownership NFT, rather, it assigns your smart contract to an existing SFS NFT
